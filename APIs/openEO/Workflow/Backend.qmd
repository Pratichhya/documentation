---
title: "Getting started with JavaScript client"
format:
  html:
    code-fold: true
---

::: {.panel-tabset}

# Python

## Exploring a back-end

If you do not know an openEO back-end that you want to connect to yet, you can have a look at the [openEO Hub](https://hub.openeo.org/){target="_blank"}, to find all known back-ends with information on their capabilities.

For this tutorial we will use the openEO instance of Google Earth Engine, which is available at `https://earthengine.openeo.org`.
Note that the code snippets in this guide work the same way for the other back-ends listed in the openEO Hub. Just the collection identifier and band names might differ.

First we need to establish a connection to the back-end. 

```python
import openeo

connection = openeo.connect("https://earthengine.openeo.org")
```

The [`Connection` object](https://open-eo.github.io/openeo-python-client/api.html#module-openeo.rest.connection){target="_blank"}
is your central gateway to
- list data collections, available processes, file formats and other capabilities of the back-end
- start building your openEO algorithm from the desired data on the back-end
- execute and monitor (batch) jobs on the back-end
- etc.


### Collections

The EO data available at a back-end is organised in so-called collections.
For example, a back-end might provide fundamental satellite collections like "Sentinel 1" or "Sentinel 2",
or preprocessed collections like "NDVI".
Collections are used as input data for your openEO jobs.

::: {.callout-note} 

More information on how openEO "collections" relate to terminology used in other systems can be found in
([the openEO glossary](../glossary.md#eo-data-collections){target="_blank"}).

:::

Let's list all available collections on the back-end,
using [`list_collections`](https://open-eo.github.io/openeo-python-client/api.html#openeo.rest.connection.Connection.list_collections):

```python
print(connection.list_collections())
```

which returns list of collection metadata dictionaries, e.g. something like:

```
[{'id': 'AGERA5', 'title': 'ECMWF AGERA5 meteo dataset', 'description': 'Daily surface meteorolociga datal ...', ...},
 {'id': 'SENTINEL2_L2A_SENTINELHUB', 'title': 'Sentinel-2 top of canopy', ...},
 {'id': 'SENTINEL1_GRD', ...},
 ...]
```

This listing includes basic metadata for each collection.
If necessary, a more detailed metadata listing for a given collection can be obtained with
[`describe_collection`](https://open-eo.github.io/openeo-python-client/api.html#openeo.rest.connection.Connection.describe_collection){target="_blank"}.

::: {.callout-note} 

Programmatically listing collections is just a very simple usage example of the Python client.
In reality, you probably want to look up or inspect available collections in a web based overview such as the [openEO Hub](https://hub.openeo.org/){target="_blank"}.

:::


### Processes

Processes in openEO are operations that can be applied on (EO) data
(e.g. calculate the mean of an array, or mask out observations outside a given polygon).
The output of one process can be used as the input of another process,
and by doing so, multiple processes can be connected that way in a larger "process graph":
a new (user-defined) processes that implements a certain algorithm.

::: {.callout-note} 

Check [the openEO glossary](./Glossary.qmd)
for more details on pre-defined, user-defined processes and process graphs.

:::


Let's list the (pre-defined) processes available on the back-end
with [`list_processes`](https://open-eo.github.io/openeo-python-client/api.html#openeo.rest.connection.Connection.list_processes){target="_blank"}:

```python
print(connection.list_processes())
```

which returns a list of dictionaries describing the process (including expected arguments and return type), e.g.: 

```
[{'id': 'absolute', 'summary': 'Absolute value', 'description': 'Computes the absolute value of a real number `x`, which is th...', 
 {'id': 'mean', 'summary': 'Arithmetic mean(average)', ...}
 ...]
```


Like with collections, instead of programmatic exploration you'll probably prefer a web-based overview such as the [openEO Hub](https://hub.openeo.org/) for back-end specific process descriptions
or browse the [reference specifications of openEO processes](https://processes.openeo.org/){target="_blank"}.

# JavaScript

If you do not know an openEO back-end that you want to connect to yet, you can have a look at the [openEO Hub](https://hub.openeo.org/), to find all known back-ends with information on their capabilities.

For this tutorial we will use the openEO instance of Google Earth Engine, which is available at `https://earthengine.openeo.org`.
Note that the code snippets in this guide works the same way for the other back-ends listed in the openEO Hub. Just the collection identifier and band names might differ.

First we need to establish a connection to the back-end.

```js
var con = await OpenEO.connect("https://earthengine.openeo.org");
```

::: {.callout-note}  

The JavaScript client uses [Promises (async/await)](https://medium.com/jspoint/javascript-promises-and-async-await-as-fast-as-possible-d7c8c8ff0abc). So there are two ways to express the code above:

Promises:
```js
OpenEO.connect("https://earthengine.openeo.org").then(function(con) {
  // Success
}).catch(function(error) {
  // Error
});
```

async/await:
```js
try {
  var con = await OpenEO.connect("https://earthengine.openeo.org");
  // Success
} catch (error) {
  // Error
}
```

To simplify the code here, we use async/await in all examples and don't catch errors. So we assume you run the code in an async function and also in a try/catch block.

:::

After establishing the connection to the back-end, it can be explored using the [Connection object](https://open-eo.github.io/openeo-js-client/latest/Connection.html) returned. The basic service's metadata (capabilities) can be accessed via 
```js
var info = con.capabilities();
```

This allows to request a couple of [different information](https://open-eo.github.io/openeo-js-client/latest/Capabilities.html), like API version, description, related links or the billing plans. You can print some of these information to the console as follows:

```js
console.log("API Version: ", info.apiVersion());
console.log("Description: ", info.description());

console.log("Billing plans:");
info.listPlans().forEach(plan => {
  console.log(`${plan.name}: ${plan.url}`);
});

console.log("Related links:");
info.links().forEach(link => {
  console.log(`${link.title}: ${link.href}`);
});
```

### Collections

Collections represent the basic data the back-end provides (e.g. Sentinel 2 collection).
Collections are used as input data for job executions ([more info on collections](../glossary.md#eo-data-collections)).
With the following code snippet you can print all 400+ available collection names and their summary.

```js
console.log("Available Collections:");
var response = await con.listCollections();
response.collections.forEach(collection => {
  console.log(`${collection.id}: ${collection.summary}`);
});
```

To get detailed information about a single collection, you can pass any of the collection IDs requested earlier to `describeCollection` and get a full object of [STAC compliant Collection metadata](https://github.com/radiantearth/stac-spec/tree/v1.0.0/collection-spec/collection-spec.md) back.
In this example we request information about the Sentinel-2 Level 1C data from Google:

```js
console.log(await con.describeCollection("COPERNICUS/S2"));
```

The collections descriptions returned by `listCollections` are usually not complete. To get the full set of metadata you should always use `describeCollection`.

### Processes

Processes in openEO are small tasks that can be applied on (EO) data.
The input of a process might be the output of another process, so that several connected processes form a new (user-defined) process itself.
Therefore, a process resembles the smallest unit of task descriptions in openEO ([more details on processes](../glossary.md#processes)).
With the following code snippet you can print all available process IDs and their summaries.

```js
console.log("Available Collections:");
var response = await con.listProcesses();
response.processes.forEach(process => {
  console.log(`${process.id}: ${process.summary}`);
});
```

In contrast to the collections, the process descriptions returned by `listProcesses` are complete.
There's no need to call `describeProcess` to get the full set of metadata.
`describeProcess` is just a convenience function to get a single process from `listProcesses`.
In this example we request the process specification for the `apply` process:

```js
console.log(await con.describeProcess("apply"));
```

For a graphical overview of the openEO processes, there is an [online documentation](../processes.md) for general process descriptions and the [openEO Hub](https://hub.openeo.org/) for back-end specific process descriptions. 

# R

If you do not know an openEO back-end that you want to connect to yet, you can have a look at the [openEO Hub](https://hub.openeo.org/), to find all known back-ends with information on their capabilities.

For this tutorial we will use the openEO instance of Google Earth Engine, which is available at `https://earthengine.openeo.org`.
Note that the code snippets in this guide work the same way for the other back-ends listed in the openEO Hub. Just the collection identifier and band names might differ.

First we need to establish a connection to the back-end. 

```r
library(openeo)
gee = connect(host = "https://earthengine.openeo.org")
```

The object stored as variable `gee` is a connection and resembles the `OpenEOClient` - an object, that bundles all information and functions to interact with the openEO back-end. It can be used explicitly in all of the functions to determine which connection has to be used (usually parameter `con`). If only one connection is active, then you can omit the parameter, because the last active connection is always stored in a package environment and used if no specific connection was present (see `?active_connection` in the package documentation).

The capabilities of the back-end and the collections are generally publicly available, unless the data collections are proprietary and licensing issues prevent the back-end provider from publishing the collection. For the publicly available information you do not need to have an account on the back-end for reading them.

### Collections

Collections represent the basic data the back-end provides (e.g. Sentinel 1 collection) and are therefore often used as input data for job executions ([more info on collections](../glossary.md#eo-data-collections)).
With the following code snippet you can get all available collection names and their description. The collection list and its entries have their own implementations of the `print` function. The collection list object is coerced into a `data.frame` only for printing purposes and the collection for the collection some key information are printed. 

To get the collection list can be indexed by the collections ID to get the more details about the overview information. With the `describe_collection` function you can get an even more detailed information about the collection.

```r
# get the collection list
collections = list_collections()

# print an overview of the available collections (printed as data.frame or tibble)
print(collections)

# to print more of the reduced overview metadata
print(collections$`COPERNICUS/S2`)

# Dictionary of the full metadata of the "COPERNICUS/S2" collection (dict)
s2 = describe_collection("COPERNICUS/S2") # or use the collection entry from the list, e.g. collections$`COPERNICUS/S2`
print(s2)
```

In general all metadata objects are based on lists, so you can use `str()` to get the structure of the list and address fields by the `$` operator.

::: {.callout-note} 

If the package is used with RStudio the metadata can also be nicely rendered as a web page in the viewer panel by running `collection_viewer(x="COPERNICUS/S2")`.

:::

### Processes

Processes in openEO are tasks that can be applied to (EO) data.
The input of a process might be the output of another process, so that several connected processes form a new (user-defined) process itself.
Therefore, a process resembles the smallest unit of task descriptions in openEO ([more details on processes](../glossary.md#processes)).
The following code snippet shows how to get the available processes.

```r
# List of available openEO processes with full metadata
processes = list_processes()

# List of available openEO processes by identifiers (string)
print(names(processes))

# print metadata of the process with ID "load_collection"
print(processes$load_collection)
```

The `list_processes()` method returns a list of process metadata objects that the back-end provides.
Each process list entry is a more complex list object (called 'ProcessInfo') and contains the process identifier and additional metadata about the process, such as expected arguments and return types. 

::: {.callout-note} 

As for the collection, processes can also be rendered as a web page in the viewer panel, if RStudio is used. In order to open the viewer use `process_viewer()` with either a particular process (`process_viewer("load_collection")`) or you can pass on all processes (`process_viewer(processes)`). When all processes are chosen, there is also a search bar and a category tree.

:::

For other graphical overviews of the openEO processes, there is an [online documentation](../processes.md) for general process descriptions and the [openEO Hub](https://hub.openeo.org/) for back-end specific process descriptions.

:::